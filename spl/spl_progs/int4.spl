///// INTERRUPT 4 /////

alias pcb_entry R0;
alias inode_table_entry R1;
alias ret_val_add R2;
pcb_entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE+1]*16;

// switch to the kernel stack
alias userSP R4;
userSP = SP;
[pcb_entry + 13] = SP;
SP = [pcb_entry + 11]*512 - 1;

// extract the system call number from the user stack
alias syscall R5;
syscall = [[PTBR + 2*(userSP-5)/512]*512 + (userSP-5)%512];

// physical address of return value
ret_val_add = [PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512;

// CREATE system call
if (syscall == 1) then
    [pcb_entry + 9] = 1;
    
    // extract file name from stack
    alias filename R6;
    filename = [([PTBR + 2 * ((userSP - 4)/ 512)] * 512) + (userSP - 4) % 512];

    // extract permission from stack
    alias permission R7;
    permission = [([PTBR + 2 * ((userSP - 3)/ 512)] * 512) + (userSP - 3) % 512];
    
    //Checking if file is already present by checking inode table
	alias i R8;
	i=0;
	while(i<60) do
		if([INODE_TABLE+16*i+1]==filename) then
			print "File Exists";
            // store 0 (success) in stack and return to user
            [ret_val_add] = 0;
            [pcb_entry + 9] = 0;
            SP = userSP;
            ireturn;
		endif;
		i=i+1;
	endwhile;

	//Finding free entry in inode table
    alias inode_free_entry R9;
	inode_free_entry=-1;
	i=0;
	while(i<60) do
		if([INODE_TABLE+16*i+1]==-1) then
			inode_free_entry=i;
			break;
		endif;
		i=i+1;
	endwhile;
    
    // if no free entry is found, return -1 to user
    if (inode_free_entry == -1) then
            // store -1 (failure) in stack and return to user
            [ret_val_add] = -1;
            [pcb_entry + 9] = 0;
            SP = userSP;
            ireturn;
    endif;

    //// INODE TABLE
    inode_table_entry = INODE_TABLE + 16*inode_free_entry;

    // set file type
    [inode_table_entry + 0] = DATA;
    // set file name
    [inode_table_entry + 1] = filename;
    // set file size
    [inode_table_entry + 2] = 0;
    // set user ID
    [inode_table_entry + 3] = [pcb_entry + 3];
    // set permission
    [inode_table_entry + 4] = permission;
    // set disk blocks
	[inode_table_entry + 8]=-1;
	[inode_table_entry + 9]=-1;
	[inode_table_entry + 10]=-1;
	[inode_table_entry + 11]=-1;

    //// ROOT FILE
    
    alias root_file_index R10;
    root_file_index = inode_free_entry;
	[ROOT_FILE + 8*root_file_index + 0] = filename; 
	[ROOT_FILE + 8*root_file_index + 1] = 0; 
	[ROOT_FILE + 8*root_file_index + 2] = DATA; 
	[ROOT_FILE + 8*root_file_index + 3] = [USER_TABLE  +  2*[pcb_entry  +  3]  + 3];
	[ROOT_FILE + 8*root_file_index + 4] = permission; 

    // store 0 (success) in stack and return to user
    [ret_val_add] = 0;
    [pcb_entry + 9] = 0;
    SP = userSP;
    ireturn;

endif;


// DELETE system call
if (syscall == 4) then
    [pcb_entry + 9] = 4;

    // extract file name from stack
    alias filename R6;
    filename = [([PTBR + 2 * ((userSP - 4)/ 512)] * 512) + (userSP - 4) % 512];

    // check if file exists in inode table
	alias i R7;
    alias inode_index R8;
    inode_index = -1;
	i=0;
	while(i<60) do
		if([INODE_TABLE+16*i+1]==filename) then
            // store inode index
            inode_index = i;
            break;
		endif;
		i=i+1;
	endwhile;

    // if file not present (already deleted), return 0
    if (inode_index == -1) then
        [ret_val_add] = 0;
        [pcb_entry + 9] = 0;
        SP = userSP;
        ireturn;
    endif;

    inode_table_entry = INODE_TABLE + inode_index*16;

    // if file is not of type DATA, return -1
    if ([inode_table_entry + 0] != DATA) then
        [ret_val_add] = -1;
        [pcb_entry + 9] = 0;
        SP = userSP;
        ireturn;
    endif;

    // permission bit can have two possible values
    // EXCLUSIVE = 0
    // OPEN_ACCESS = 1

    // if exclusive permission is set
    if ([inode_table_entry + 4] == EXCLUSIVE) then
        // if current user is not root / current user is not the file owner
        if ([pcb_entry + 3] != 1 && [pcb_entry + 3] != [inode_table_entry + 3]) then
            [ret_val_add] = -1;
            [pcb_entry + 9] = 0;
            SP = userSP;
            ireturn;
        endif;
    endif;

	//ACQUIRING INODE
	backup;
		R1=4; //Function number of Acquire inode in MOD_1
		R2=[SYSTEM_STATUS_TABLE+1]; //PID of current process
		R3=inode_index;
		call MOD_0;	
	restore;

	if([FILE_STATUS_TABLE + inode_index*4 +1]!=-1) then
		//RELEASING INODE
        print "FileOpen";
		backup;
			R1=5; //Function number of Release inode in MOD_1
			R2=[SYSTEM_STATUS_TABLE+1]; //PID of current process
			R3=inode_index;
			call MOD_0;	
		restore;

        // return -2 : File is open, cannot be deleted
        [ret_val_add] = -2;
        [pcb_entry + 9] = 0;
        SP = userSP;
        ireturn;
	endif;

	//Checking if disk blocks allocated to process are present in buffer
    alias buffer_number R9;
	i=8;
	while(i<=11) do
        //If the block in in buffer
        buffer_number = [inode_table_entry + i]%MAX_BUFFER;
        if([BUFFER_TABLE + 4*buffer_number + 0]== [INODE_TABLE+16*inode_index+i]&& 
            [BUFFER_TABLE + 4*buffer_number + 1]==1) then
            [BUFFER_TABLE + 4*buffer_number + 1]=0;
        endif;

        //RELEASE BLOCK
        backup;
            R1=4; //Function number of Release block in MOD_1
            R2=[INODE_TABLE+16*inode_index+i]; // Block no. to be released
            call MOD_2;	
        restore;
        i=i+1;
	endwhile;

	//Invalidating Inode entry
	[inode_table_entry + 1]=-1;

	//Invalidating root file entry
    alias root_file_index R10;
	root_file_index = inode_index;
	[ROOT_FILE + 8*root_file_index+1]=-1;

	//RELEASING INODE
	backup;
		R1=5; //Function number of Release inode in MOD_1
		R2=[SYSTEM_STATUS_TABLE+1]; //PID of current process
		R3=inode_index;
		call MOD_0;	
	restore;

    // store 0 (success) in stack and return to user
    [ret_val_add] = 0;
    [pcb_entry + 9] = 0;
    SP = userSP;
    ireturn;

endif;
