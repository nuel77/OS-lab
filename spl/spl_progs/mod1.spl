///// PROCESS MANAGER MODULE /////
alias functionNum R1;
alias PID R2;

// Get pcb entry (function no. = 1)
if (functionNum == 1) then
    // loop through all process table entries to find a free entry
    alias i R1;
    i = 0;
    while (i<16) do
        if ([PROCESS_TABLE + i*16 + 4] == TERMINATED) then
            // if found, use the entry for the child process
            [PROCESS_TABLE + i*16 + 1] = i;
            [PROCESS_TABLE + i*16 + 4] = ALLOCATED;
            [PROCESS_TABLE + i*16 + 14] = PAGE_TABLE_BASE + i*20;
            [PROCESS_TABLE + i*16 + 15] = 10;
            // return value
            R0 = i;
            break;
        endif;
        i = i+1;
    endwhile;
    // if no free pcb entry, return -1
    if (i==16) then
        R0 = -1;
    endif;
    return;
endif;


// Free User Area Page function (function no = 2)
if (functionNum == 2) then
    // When a process terminates, all the semaphores the process has acquired (and haven't released explicitly) have to be released
    alias i R3;
    i = 0;
    while (i < 16) do
        
        // releasing all unreleased semaphores
        if (i%2 == 0 && [[PROCESS_TABLE + PID*16 + 11]*512 + 496 + i] == SEMAPHORE) then
            // call release semaphore in resource manager module
            multipush(R1,R2,R3);
            R1 = 7;
            R2 = [SYSTEM_STATUS_TABLE+1];
            R3 = [[PROCESS_TABLE + PID*16 + 11]*512 + 496 + i + 1];
            call MOD_0;
            multipop(R1,R2,R3);
        endif;

        // closing all open files (opened by this process)
        if (i%2 == 0 && [[PROCESS_TABLE + PID*16 + 11]*512 + 496 + i] == FILE) then
            // call "close" in file manager module
            multipush(R1,R2,R3);
            R1 = 4;
            R2 = [[PROCESS_TABLE + PID*16 + 11]*512 + 496 + i + 1];
            call MOD_3;
            multipop(R1,R2,R3);
        endif;
        i = i + 1;
    endwhile;

    // Now release the page
    multipush(R1,R2);
    R1 = 2;
    R2 = [PROCESS_TABLE + PID*16 + 11];
    //releasepage(UAPageNum) --> function 2 in memory manager  module
    call MOD_2;
    multipop(R1,R2);
    return;
endif;

// Exit Process Function (function no = 3)
if (functionNum == 3) then

    multipush(R1,R2);
    R1 = 4;
    call MOD_1;
    multipop(R1,R2);
    multipush(R1,R2);
    R1 = 2;
    call MOD_1;
    multipop(R1,R2);
    [PROCESS_TABLE + PID*16 + 4] = TERMINATED;

    // wake up all processes waiting for the dying process
    // unless exit process func. is being called by EXEC
    if ([PROCESS_TABLE + PID*16 + 9] != 9) then
        alias i R4;
        i = 0;
        while (i<16) do
            if ([PROCESS_TABLE + i*16 + 4] == WAIT_PROCESS && [PROCESS_TABLE + i*16 + 5] == PID) then
                // READY all waiting processes
                [PROCESS_TABLE + i*16 + 4] = READY;
            endif;
            if ([PROCESS_TABLE + i*16 + 2] == PID) then
                // orphan all child processes (set their PPID to -1)
                [PROCESS_TABLE + i*16 + 2] = -1;
            endif;
            i = i + 1;
        endwhile;
    endif;
    return;
endif;

// Free Page Table Function (function no = 4)
if (functionNum == 4) then
    PTBR = [PROCESS_TABLE + PID*16 + 14];
    PTLR = [PROCESS_TABLE + PID*16 + 15];
    // Invalidate Library entries
	[PTBR + 0] = -1;
	[PTBR + 1] = "0000";
	[PTBR + 2] = -1;
	[PTBR + 3] = "0000";
    // Release all other pages and invalidate page table entries
    alias i R3;
    i = 4;
    while(i < PTLR*2) do
        if ([PTBR + i] != -1) then
            multipush(R1,R2);
            R1 = 2;
            R2 = [PTBR + i];
            // releasepage(pg no in R2)
            call MOD_2;
            [PTBR + i] = -1;
            [PTBR + i + 1] = "0000";
            multipop(R1,R2);
        endif;
        i=i+2;
    endwhile;

    alias dmt_entry R3;
    dmt_entry = DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE+1]*10; 

    // check for valid entries in heap and stack entries of DISK MAP TABLE
    // if found, invoke release block from memory manager
    if([dmt_entry + 2] != -1) then
        multipush(R1,R2);
        R1 = 4;
        R2 = [dmt_entry + 2];
        call MOD_2;
        multipop(R1,R2);
    endif;
    if([dmt_entry + 3] != -1) then
        multipush(R1,R2);
        R1 = 4;
        R2 = [dmt_entry + 3];
        call MOD_2;
        multipop(R1,R2);
    endif;
    if([dmt_entry + 8] != -1) then
        multipush(R1,R2);
        R1 = 4;
        R2 = [dmt_entry + 8];
        call MOD_2;
        multipop(R1,R2);
    endif;
    if([dmt_entry + 9] != -1) then
        multipush(R1,R2);
        R1 = 4;
        R2 = [dmt_entry + 9];
        call MOD_2;
        multipop(R1,R2);
    endif;

    // Invalidate all DISK MAP TABLE entries

    // heap
    [dmt_entry + 2] = -1;
    [dmt_entry + 3] = -1;
    // code
    [dmt_entry + 4] = -1;
    [dmt_entry + 5] = -1;
    [dmt_entry + 6] = -1;
    [dmt_entry + 7] = -1;
    // stack
    [dmt_entry + 8] = -1;
    [dmt_entry + 9] = -1;

    return;
endif;

// Kill all
if (functionNum == 5 ) then

	alias i R5;
	i=0;

    // Acquire inode for all files
	while(i<60) do
		if([INODE_TABLE+16*i+1]!=-1) then
			multipush(R0,R1,R2,R3,R4,R5);
				R1=4;
				R2=[SYSTEM_STATUS_TABLE+1];
				R3=i;
				call MOD_0;
			multipop(R0,R1,R2,R3,R4,R5);
		endif;
		i=i+1;
	endwhile;

    //  If pid != pid of the current process AND state of the process in the process table entry is not TERMINATED
	i=2;
	while(i<=MAX_PROC_NUM - 1) do
		if(i!=[SYSTEM_STATUS_TABLE+1] && [PROCESS_TABLE+16*i+4]!=TERMINATED) then
			backup;
				R1=3;
				R2=i;
				call MOD_1;
			restore;
		endif;
		i=i+1;
	endwhile;
    
    // Release inodes
	i=0;
	while(i<MAX_FILE_NUM) do
		if([INODE_TABLE+16*i+1]!=-1) then
			backup;
				R1=5;
				R2=[SYSTEM_STATUS_TABLE+1];
				R3=i;
				call MOD_0;
			restore;
		endif;
		i=i+1;
	endwhile;
    return;

endif;
