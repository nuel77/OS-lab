///// RESOURCE MANAGER MODULE /////

alias functionNum R1;
alias currentPID R2;

// ACQUIRE INODE
if (functionNum == 4) then

	alias index R3;
	while([FILE_STATUS_TABLE+4*index+0]!=-1) do
		[PROCESS_TABLE+16*currentPID+4]=WAIT_FILE;
		[PROCESS_TABLE+16*currentPID+5]=index;
		backup;
		call MOD_5;
		restore;
	endwhile;

	//Checking if file is deleted
	if([INODE_TABLE+16*index+1]==-1) then
		R0=-1;
		return;
	endif;

	//Locking the inode
	[FILE_STATUS_TABLE+4*index+0]=currentPID;

	R0=0;
	return;

endif;




// RELEASE INODE
if (functionNum == 5) then

	alias index R3;
	if(currentPID != [FILE_STATUS_TABLE+4*index+0]) then
		R0=-1;
		return;
	endif;

	//Setting lock field to -1
	[FILE_STATUS_TABLE+4*index+0]=-1;

	alias i R4;
	i=0;
	while(i<=15) do
		if([PROCESS_TABLE+16*i+4]==WAIT_FILE &&
			[PROCESS_TABLE+16*i+5]==index) then

			[PROCESS_TABLE+16*i+4]=READY;
		endif;
		i=i+1;
	endwhile;

	R0=0;
	return;


endif;








// ACQUIRE TERMINAL
if (functionNum == 8) then      
    while([TERMINAL_STATUS_TABLE] == 1) do
        [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 4] = WAIT_TERMINAL;     // Set state of current process to 'waiting for terminal resource'
        multipush(R1,R2,R3);
        call MOD_5;             // Call scheduler module
        multipop(R1,R2,R3);
    endwhile;
    [PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE + 1] + 4] = 1;     // Set state of current process to user mode
    [TERMINAL_STATUS_TABLE + 1] = [SYSTEM_STATUS_TABLE + 1];    // Terminal is being used by the current process
    [TERMINAL_STATUS_TABLE] = 1;                                // Terminal acquired
    return;
endif;



// RELEASE TERMINAL
if (functionNum == 9) then
    alias retVal R0;
    if (R2 != [TERMINAL_STATUS_TABLE + 1]) then      // check if the terminal was acquired by the currently runnning process
        retVal = -1;        // -1 return value indicates that the process tried to release the terminal, without acquiring it
        return;
    endif;
    [TERMINAL_STATUS_TABLE] = 0; // STATUS field set to zero --> Terminal is now released

    // Search for processes in WAIT_TERMINAL state
    alias count R3;
    count = 0;
    while(count <= 15) do
        if ([PROCESS_TABLE + count*16 + 4] == WAIT_TERMINAL) then
            [PROCESS_TABLE + count*16 + 4] = READY;
        endif;
        count = count + 1;
    endwhile;
    retVal = 0;             // success
    return;
endif;



// ACQUIRE DISK
if (functionNum == 3) then

    [75*512+2] = [75*512+2] + 1;

    // If disk is not free, calling process is set to 'WAIT_DISK'
    // and the scheduleris invoked
    if ([DISK_STATUS_TABLE + 0] == 1) then
        [PROCESS_TABLE + currentPID*16 + 4] = WAIT_DISK;
        // call scheduler
        multipush(R1,R2);
        call MOD_5;
        multipop(R1,R2);
    endif;
    // STATUS field
    [DISK_STATUS_TABLE + 0] = 1;
    // PID field
    [DISK_STATUS_TABLE + 4] = currentPID;
    return;
endif;



// ACQUIRE SEMAPHORE
if (functionNum == 6) then
    // find free entry in semaphore table 
    alias i R3;
    i = 0;
    while (i < MAX_SEM_COUNT) do
        if ([SEMAPHORE_TABLE + 4*i + 1] == 0) then
            // set locking PID
            [SEMAPHORE_TABLE + 4*i + 0] = -1;
            // set no. of process using the semaphore to 1
            [SEMAPHORE_TABLE + 4*i + 1] = 1;
            R0 = i;
            return;
        endif;
        i = i+1;
    endwhile;
    // if no free semaphores are available, return -1
    if (i == MAX_SEM_COUNT) then
        R0 = -1;
        return;
    endif;

endif;




// RELEASE SEMAPHORE
if (functionNum == 7) then
    alias SEMID R3;
    if ([SEMAPHORE_TABLE + SEMID*4] == currentPID) then
        // unlock semaphore
        [SEMAPHORE_TABLE + SEMID*4] = -1;
        // wake up all processes waiting for semaphore
        alias i R4;
        i = 0;
        while (i<16) do
            if ([PROCESS_TABLE + i*16 + 4] == WAIT_SEMAPHORE && [PROCESS_TABLE + i*16 + 5] == SEMID) then
                [PROCESS_TABLE + i*16 + 4] = READY;
            endif;
            i = i+1;
        endwhile;
        // decrement process count of semaphore table
        [SEMAPHORE_TABLE + SEMID*4 + 1] = [SEMAPHORE_TABLE + SEMID*4 + 1]-1;
    endif;
endif;
